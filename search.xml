<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS 使用Cocoapods创建自己的Cocoapods公共库]]></title>
      <url>%2F2017%2F03%2F16%2FiOS-%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Cocoapods%E5%85%AC%E5%85%B1%E5%BA%93%2F</url>
      <content type="text"><![CDATA[使用pod管理代码的好处通常在开发的过程中，大多时候，我们会处理一类相同的操作，比如对于字符串String的邮箱验证，是否为空，手机号验证，或者一些UIView的动画操作，我们为了避免写一些重复的代码，可能经过类目或者延展的形式对原有的类进行了一个扩充。还有一些是工程中一些基本的公共组件，比如城市列表，刷新控件，网络请求库或者商品的目录这种基本公共组件，在工程中好多地方需要调用，我们都可以进行封装成一个组件功能模块。为了以后方便在其他App中使用，我们可以使用Cocoapods把这些小点子，小功能，可以封装成一个pod，当下次使用的时候，只需简单配置就可以了。这一点特别是在公司开发多个项目的时候，可以很方便快速的共享公共的代码，节约开发时间，这就是为什么好多公司喜欢组件化管理代码。至于库是创建私有的还是公共的，看自己和公司要求而定，大多情况下公司的是私有库pod。本篇主要以创建公共库示例，进行阐述。 1. 创建一个工程1.打开终端，切换到你要创建的位置的目录，我这里是桌面/desktop/pod12cd desktop/podpod lib create LPodTest 当被问及创建Swift还是OC项目，按自己要求回答，我选择ObjC； 当被问及是否创建一个demo应用包含在工程里，根据需要，如果需要写一个demo示例，就选择Yes，否则选择NO，我这里选择Yes； 当被问及是否需要使用测试Framwork，选择NO； 当被问及是否需要做接界面调试，我这里选择NO； 还有一个就是工程文件的前缀，我这里是自己的名字的缩写，这个随意写； 2.填写Pod的Metadata和验证 .podspec这个文件主要是用来描述pod的版本号，首页（homepage),作者信心等，具体的可以参看官方offical reference page README如果你使用过GitHub，你肯定知道README文件的重要性，这个文件可以使用Markdown语法，主要展示在GitHub工程上的首页。README文件对于使用这个pod库的人来说，有和没有这个文件，区别是很明显的，此外这还有助于创建一个高质量的 CocoaPods Quality Index ； LICENSE要想是Spec仓库接收，就必须包含一个license。命令pod lib create 自动创建使用的是 MIT license；其实通过pod lib lint 这个命令,Cocoapods已经帮我们创建了一个模板我们只需要在里面根据需要你进行配置即可.没有用到的注释(#开头的)可以删除掉,看起来舒服一些. 接下来,我们做一个远程验证12345678pod lib lint LPodTest.podspec-&gt; LPodTest (0.1.0)- WARN | url: The URL (https://github.com/LDreame/LPodTest) is not reachable.[!] LPodTest did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it) and all results apply only to public specs, but you can use ```--private` to ignore them if linting the specification for a private pod.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`.You can use the `--no-clean` option to inspect any issue. 这个意思是告诉我们,LPodTest.podspec文件里面有一个不符合要求,需要进行修改:需要指定一个可用的pod的首页URL,因为我们还没有在GitHub上面创建任何项目有关的信息,所以不能通过因为我的LPodTest.podspec文件s.summary 和s.description已经简单的做了介绍,如果没有做任何修改的话,还会出现以下两个警告:12- WARN | The summary is not meaningful.- WARN | The description is not meaningful. 如果按照上面的步骤一步一步下来,我们还没有在GitHub上面创建相关的仓库,因此可以先进入GitHub账户创建仓库 接下来就需要把自己的工程推送到Github:1234git add .git commit -m “Initial Commit&quot;git remote add origin https://github.com/&lt;GITHUB_USERNAME&gt;/YourPodName.git // replace &lt;GITHUB_USERNAME&gt; with your github.com usernamegit push -u origin master 做完以上操作没有问题的话, 就可以做验证了:12345pod lib lint LPodTest.podspec-&gt; LPodTest (0.1.0)LPodTest passed validation. 只要见到passed validation就是成功通过了验证. #3. 添加自己的代码通过以上步骤,我们只是创建了一个合格的空的工程,并没有实现任何功能,接下来我们就需要把自己要实现的功能代码方进去.找到工程中ReplaceMe文件,替换就可以.如果你在创建工程时候创建了一个包含demo的工程,那么你可以先切换到工程的Example文件目录下面使用命令:123456789pod install Analyzing dependenciesFetching podspec for `LPodTest` from `../`Downloading dependenciesInstalling LPodTest 0.1.0 (was 0.1.0)Generating Pods projectIntegrating client projectSending statsPod installation complete! There is 1 dependency from the Podfile and 1 total pod installed. 成功以后你就可以在demo文件中使用你的功能文件了.如果不能导入,那么可以commond + B编译一下再导入使用 4. 提交自己的podStep 1: TaggingSpecs仓库是用来存放GitHub上面所有公共Pod的索引的文件,我们要做到就是让本地的pod在Specs建立联系.在做这个之前,需要将我们完善后的工程代码,打一个tag,同步到服务端:12345git tag 0.1.0qddios2deiMac:example qddios$ git push origin 0.1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:LDreame/LPodTest.git* [new tag] 0.1.0 -&gt; 0.1.0 Step 2 :验证终端切换到LPodTest.podspec文件所在的目录下面,运行命令1234567pod spec lint LPodTest.podspec-&gt; LPodTest (0.1.0)Analyzed 1 podspec.LPodTest.podspec passed validation. Step 3 : 提交pod 到Specs仓库123456789101112131415pod trunk push LPodTest.podspecUpdating spec repo `master`Validating podspec-&gt; LPodTest (0.1.0)Updating spec repo `master`--------------------------------------------------------------------------------🎉 Congrats🚀 LPodTest (0.1.0) successfully published📅 March 3rd, 03:07🌎 https://cocoapods.org/pods/LPodTest👍 Tell your friends!-------------------------------------------------------------------------------- 5. pod search 检验是否可用大多情况下会出现这个问题:1[!] Unable to find a pod with name, author, summary, or descriptionmatching `LPodTest` 这主要是因为在本地索引里面没有, 解决办法 pod setup (不行,实用方法二) pod repo update(不行,试用方法三) 前往这个路径下~/Library/Caches/CocoaPods删除search_index.json文件 , 或者使用终端命令删除:1rm ~/Library/Caches/CocoaPods/search_index.json 然后重新搜索.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods中Podfile文件的创建和使用]]></title>
      <url>%2F2017%2F03%2F16%2FCocoapods%E4%B8%ADPodfile%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、 Podfile 的作用简单来说，Podfile文件中详细记录了xcode工程中Target对于第三方库依赖的描述，里面包含了iOS platform,source, pod name , pod version, 以及对于多Target的项目中，不同Target对pod库依赖的设置。 二、创建一个Podfile文件 首先在桌面创建一个工程CocoaPodsTest，打开终端，切换到CocoaPodsTest项目的根目录下,此时还没有Podfile文件*pod init在终端中使用pod init命令可以直接产生一个Podfile文件 此外除了pod init 还可以直接在工程根目录下直接 使用vim Podfile命令运行这个命令，如果已经存在Podfile，那么直接打开，否则将创建一个Podfile文件并打开。两者的区别是pod init 初始化了一些必要的代码，而直接使用vim Podfile的话，创建并打开的是一个空白的文档。 下面的是pod init创建的Podfile，而vim Podfile则是空白什么也没有 三、给工程添加依赖库 单个Target添加 多Target添加， 可以共享，也可以指定每一个Target具体可以参考Cocoapods官方的例子; 四、版本号控制 pod &#39;AFNetworking&#39;这种格式是使用最新的版本，忽略了版本的要求*pod &#39;AFNetworking&#39;, &#39;3.1.0&#39; 这种格式是只能使用版本3.1.0；除了以上了；两种没有版本号和指定版本号，还可以进行逻辑判断 &#39;&gt; 0.1&#39; 任何大于0.1的版本都可以 ‘&gt;= 0.1’ 0.1以及0.1以上的版本*&#39;&lt; 0.1&#39;低于0.1的版本 &#39;&lt;= 0.1&#39; 0.1以及0.1以下的版本*&#39;~&gt; 0.1.2&#39; 这个是指版本0.1.2到版本0.2，但不包括0.2版本和0.2以上的版本 &#39;~&gt; 0.1&#39;这个是指版本0.1到版本1.0，但不包括1.0版本和1.0以上的版本 &#39;~&gt; 0&#39;这个作用和没有写版本号作用是一样]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapos 的使用]]></title>
      <url>%2F2017%2F03%2F16%2FCocoapos-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、 什么是CocoapodsCocoapods 是专门为xcode设计,用来管理第三方代码库的工具；所需的第三方依赖库，需要在Podfile文件里面进行配置。 许多人刚开始使用cocopods的时候，可能认为pod install 只是在首次配置自己项目的时候使用，pod update在以后使用，那么这样认为就大错特错了 二、 pod install vs. pod update 、pod outdated pod install 是用来安装一个新的pods依赖库，或者说pod install 当你想把一个pods 依赖移除或者添加到工程的时候使用； pod update 仅仅是望你想要更新pods到较新版本的时候使用 当运行pod install 命令的时候，它的操作步骤是：下载和安装新的pods— 在Podfile.lock文件写入每一个已经安装pods的版本号；这个文件用来追踪和锁定所安装的pods的版本号。 pod install 仅仅处理那些没有在podfile.lock列出的依赖库pods。对于已经在Podfile.lock文件里的pods,它仅仅下载在Podfile.lock里面锁定的版本，并不去检查是否有可用的最新版本；对于没有在Podfile.lock的pods，它会搜索和匹配在Podfile文件里面所描述的对应的版本（e.g pod &#39;AFNetworking&#39;, &#39;~&gt;3.0&#39;)。 pod outdated命令 Cocoapods会列出项目中Podfile.lock文件里面锁定的版本具有新版本可以更新的pods。这个是我的工程里面对应的Podfile， 列出了工程需要的依赖库：下面这个截图是 pod outdated命令后，找出了有新版本可以更新的第三方库下面的截图是Podfile.lock文件中锁定的第三方库的版本，以及对应的版本号 对比截图二和截图三，我们可以看出，在Podfile.lock文件中，Masonry、SDWebImage、Realm这三个库锁定的版本号是比较老的版本，运行命令pod outdated后，就列出了可以更新的版本号。 pod update 当你运行 pod update podName, Cocoapods会找出podName 可以更新的的版本（除了在Podfile.lock里面已经列出锁定的版本）， 它会根据Podfile.lock文件里面的限制条件，尽可能对升级podName到比较新的可用的版本。如果pod update 后面不添加podName的话，Cocoapods 会根据Podfile文件里面列出的pods,把每一个pod更新到相应比较新的可用的版本。 三、 那么到底在那些场景下使用呢用呢？ 对于pod update PODNAME 这个命令，仅仅是更新一个特定的pod(这个操作会根据Podfile文件的配置检测特定的pod是否存在可更新版本，如果就相应的进行更新）。与之相反的是命令pod install这个命令并不会尝试检测更新已经安装pod。 当你在Podfile里面添加了新的pod，那么最好选择使用pod install，而不是选择pod update , 因为pod install 可以避免安装和 更新操作在一个线程里面进行，从而提高效率，节省安装时间，但这并不是说 pod update 不行，而是相对来说这种场景下用pod install更好一些。 pod update 命令，当你想要更新某一个特定的pod 或者所有的pod的时候是最好的选择。 四、Commit 提交 Podfile.lock作为一个提醒：即使你的代码管理策略中，提交代码的时候并不提交Pods文件夹到共享的代码仓库中，但是提交和上床Podfile.lock文件是很有必要的，否则的话，上面对于命令 pod install的功能解释（pod install可以安装锁定的相应版本）将不再适用。 五、适用场景举例 阶段一：用户user1创建了一个工程user1 创建了一个工程，想使用pods A 、B 、C, 那么然后创建一个Podfile， 将对应的版本添加到Podfile里面，运行 pod install , 将会安装 A、B、C，我们假设此时指定使用的版本都为1.0.0;Podfile.lock 将会持续追踪限制安装A、B、C的版本都为1.0.0； 此外：因为这是第一次运行pod install命令， 此时Pods.xcodeproj并不存在， 那么运行 pod install命令后，除了安装pods外，还会创建Pods.xcodeproj和.xcworkspace。 阶段2: 用户user1 添加了一个新的pod不久后，user1想添加一个 pod D到Podfile文件。这时运行pod install之后，即使这个时候对于pod B有一个 用于维护的 Released 1.1.0版本，那么工程任然会保持pod B是版本1.0.0，因为用户user1 想要的是 pod D， 而不是其他版本的pod B。 阶段3： 用户user2加入工程对于user2 加入这个团队之前从没用在这个工程工作过，他将会clone仓库并且pod install；Podfile.lock文件的内容（这个内容应该是被提交到git 仓库的）将会保证user2获得的pod 和user1正在使用的pod是一样版本的pod；即使现在对于pod C有一个1.2.0可用的版本，user2 也只会安装使用 C 1.0.0版本，这就要归功于Podfile.lock了， 因为 pod C在Podfile.lock中注册的版本是1.0.0，所以Podfile.lock就会锁定pod C只能安装使用1.0.0版本； 阶段4： 检测新的可用pod之后，user1 想知道那些pods更新了，那么可以运行pod outdated, Cocoapods将会列出有更新可用的pods, 比如 pod B 有一个1.1.0可用的新版本，pod C 有一个 1.2.0可用的新版本；user1 决定更新pod B而不更新pod C， 那么运行 pod update B, 将会将 B由版本1.0.0更新到1.1.0（相应的，Podfile.lock 也进行更新）pod C将仍然是1.0.0而不是1.2.0； 六、在Podfile 中使用确切的版本并不能适用所有场景一些开发者可能认为只要在Podfile文件中制定了特定的版本比如pod ‘A’, ‘1.0.0’， 就可以保证所有团队成员可以使用相同的pod 版本，其实并不是这样。有一个经典的例子：如果pod A有一个pod依赖 A2，并且在pod A的podspec中进行了声明：dependency &#39;A2&#39;, &#39;~&gt; 3.0&#39;， 在这种场景下在Podfile文件中声明pod &#39;A&#39;, &#39;1.0.0&#39;确实能够保证user1和user2两者总是使用版本1.0.0，但是 user1 可以使用 pod A2 3.4.0版本(在user1使用的时候假设A2 3.4.0版本是最新的可用） user2随后加入团队后，pod install获得的是 pod A2 3.5.0的版本（因为在user2的时候假设 3.5.0是可用的）这就是为什么说使用Podfile.lock是唯一的途径让不同开发人员在不同的电脑上使用相同的pod的版本，并且要适当使用 pod install和 pod update。]]></content>
    </entry>

    
  
  
</search>
